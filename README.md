# Go-GenDB

go-gendb is a tool for quickly generating Go database access code. Through it, we can define complex sql statements externally (in sql file) and define the interface for executing these sql statements in the Go code. go-gendb can automatically generate the implementation of this interface to realize the execution of sql.

go-gendb can even connect to a remote database, and automatically generate the corresponding Go structure and simple CRUD code for a table in the database.

go-gendb can bring the following conveniences for Go developers to write database code:

- It is no longer necessary to manually define a mapping structure for a table and their basic `ORM` operation codes (for example, insert one record, query based on Id, etc.).
- For complex queries (such as associated queries, sub-queries), it can be defined in an external sql file. Reference in the form of interfaces in Go code. Such references will be created automatically. You can only care about the definition of the interface and the writing of sql statements. The calling process does not involve reflection, and the efficiency is almost the same as writing code by yourself.
- For query statements, it is no longer necessary to write a lot of repetitive and mechanical `rows.Scan` code. go-gendb will automatically parse the fields in the SELECT clause in the SQL statement, and the Scan deserialization code will be automatically generated!
- Generate code by using tags (`+gendb`) in the Go code. No additional configuration files are involved, easy to use and lightweight.
- Support some more advanced SQL statement functions, such as dynamic SQL statement, SQL statement reuse, etc.
- Support to generate a variety of database codes, such as MySQL, MongoDB, etc. And support the generation of L2 cache code, including remote cache (usually Redis), local LRU cache. And can ensure data consistency through distributed locks based on different implementations (see the advanced usage document for details).

## Install

go-gendb is a command line program that runs in the terminal. Support darwin, Linux, Windows system. You can download the binary program of the corresponding system directly from the release page.

A better installation method is to clone the code directly to the local build and install. This method requires at least `Go 1.11` or higher on your machine:

```text
$ git clone https://github.com/fioncat/go-gendb.git
$ cd go-gendb
$ export GO111MODULE=on    # This command is to open go module, if it is already opened, can be ignored.
$ go install
```

If the installation goes well, execute the following command, you should see the version of go-gendb:

```text
$ go-gendb version
```

## Quick Start

Suppose we have a user table in the database(MySQL):

```sql
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'user id',
  `name` varchar(50) DEFAULT NULL COMMENT 'user name',
  `email` varchar(50) DEFAULT NULL COMMENT 'user email',
  `phone` varchar(50) DEFAULT NULL COMMENT 'user phone',
  `age` int(11) DEFAULT NULL COMMENT 'user age',
  `create_time` datetime DEFAULT NULL COMMENT 'user create time',
  `password` varchar(50) DEFAULT NULL COMMENT 'user password',
  `is_admin` int(11) DEFAULT NULL COMMENT 'admin flag 0-no admin  1-admin',
  `is_delete` int(8) DEFAULT '0',
  
  PRIMARY KEY (`id`)
  
) ENGINE=InnoDB;
```

First define an interface code file, which describes what kind of code needs to be generated. Including which structures to generate and which methods.

> examples/user/user.db.go

```go
// +gendb mysql

package user

import "database/sql"

type User struct {
  
    // generate tags for struct "userORM"
    // +gendb-struct user
    // +gendb-ignore is_delete
    // +gendb-type is_admin bool
  
    // UserORM will be automatically generated, it includes the 
    // fields in the table user. The field name will be 
    // automatically converted to Hump form (Id, Name, IsAdmin, etc.), and 
    // the type will be automatically inferred based on the database type.
    // There are some additional configurations. The "ignore" option
    // means to ignore the is_delete field.
    // The "type" option manually specifies the GO type of a field.
    UserORM
}

// This tag indicates that an implementation structure will be generated 
// for interface UserDB. The sql statement will be read from "user.sql" in 
// the current directory.
// +gendb-inter user.sql

// UserDB defines some operation methods of the user table. 
// The specific implementation of these methods is automatically 
// generated by gendb. Their sql statements are defined in 
// external sql files.
type UserDB interface {
    Add(db *sql.DB, u *User) (int64, error)
    Update(db *sql.DB, u *User) (int64, error)
    FindByID(db *sql.DB, id int64) (*User, error)
    FindByName(db *sql.DB, name string) ([]*User, error)
    Search(db *sql.DB, where string, offset int32, limit int32) ([]*User, error)
    Count(db *sql.DB, where string) (int64, error)
}
```

Then define the sql file to define sql statements for each method of the `UserDB` interface. In the SQL statement, special placeholders `${name}` and `#{name}` are needed to introduce function parameters:

> examples/user/user.sql

```sql
-- !Add
INSERT INTO user(name, email, phone, age, password)
VALUES (${u.Name}, ${u.Email}, ${u.Phone}, ${u.Password});

-- !Update
UPDATE user SET name=${u.Name}, email=${u.Email}, phone=${u.Phone}, password=${u.Password}
WHERE id=${u.Id};

-- !FindByID
SELECT id, name, email, phone, age, password, create_time, is_admin
FROM user WHERE id=${id};

-- !FindByName
SELECT id, name, email, phone, age, password, create_time, is_admin
FROM user WHERE name=${name};

-- !Search
SELECT id, name, email, phone, age, password, create_time, is_admin
FROM user
WHERE 1=1 #{where}
LIMIT ${offset}, ${limit};

-- !Count
SELECT COUNT(1)
FROM user
WHERE 1=1 #{where};
```

First of all, because the user table needs to be read from the database to generate the `userORM` structure, the database connection needs to be configured through the following command, command will ask you to input configuration:

```text
$ go-gendb conn-set
Please input conn key: test
Please input addr: your address
Please input user: your user
Please input password: your password
Please input database: your database
```

Then run the following command to generate code:

```text
$ go-gendb gen --log --cache --conn test examples/user/user.db.go
```

This will generate two codes. The first code is the userORM structure, which is:

> examples/user/zz_generated_struct_UserORM.go

```go
// Code generated by go-gendb. DO NOT EDIT.
// go-gendb version: 0.0.1
// source: examples/user/user.db.go
package user

import (
    time "time"
)

// UserORM
type UserORM struct {
    // Id user id
    Id int64 `table:"user" field:"id"`
    // Name user name
    Name string `table:"user" field:"name"`
    // Email user email
    Email string `table:"user" field:"email"`
    // Phone user phone
    Phone string `table:"user" field:"phone"`
    // Age user age
    Age int32 `table:"user" field:"age"`
    // CreateTime user create time
    CreateTime time.Time `table:"user" field:"create_time"`
    // Password user password
    Password string `table:"user" field:"password"`
    // IsAdmin admin flag 0-no admin  1-admin
    IsAdmin bool `table:"user" field:"is_admin"`
}
```

The other is the implementation of the UserDB interface(Omit detailed code):

> examples/user/zz_generated_sql_UserDB.go

```go
// Code generated by go-gendb. DO NOT EDIT.
// go-gendb version: 0.0.1
// source: examples/user/user.db.go
package user

...

// UserDBImpl implement of UserDB
type UserDBImpl struct {
}

// Add implement of Add
func (*UserDBImpl) Add(db *sql.DB, u *User) (int64, error) {
    ...
}

// Update implement of Update
func (*UserDBImpl) Update(db *sql.DB, u *User) (int64, error) {
    ...
}

// FindByID implement of FindByID
func (*UserDBImpl) FindByID(db *sql.DB, id int64) (*User, error) {
    ...
}

// FindByName implement of FindByName
func (*UserDBImpl) FindByName(db *sql.DB, name string) ([]*User, error) {
    ...
}

// Search implement of Search
func (*UserDBImpl) Search(db *sql.DB, where string, offset int32, limit int32) ([]*User, error) {
    ...
}

// Count implement of Count
func (*UserDBImpl) Count(db *sql.DB, where string) (int64, error) {
    ...
}
```

In fact, the above simple SQL does not need to write SQL statements yourself. Methods like Add, Update, and Count can be generated automatically. But this advanced usage is not used here for the sake of simplicity. For advanced usage, please refer to the document: document.

The code generated above can be used very conveniently:

```go
package main

import (
    "fmt"

    "github.com/fioncat/go-gendb/examples/user"
)

func main() {
      // init database connection
    db := initDB()
      
    var u user.User
    u.Name = "fioncat"
    u.Age = 23
    u.Email = "lazycat7706@gmail.com"
    u.IsAdmin = true
  
    _, err := user.UserDBOper.Add(db, &u)
    if err != nil {
        fmt.Printf("insert user failed: %v\n", err)
        return
    }
    fmt.Println("insert user success.")
}
```

The above example code can be found under [examples/user](examples/user) of the project.