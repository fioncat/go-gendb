package coder

import (
	"fmt"
	"io/ioutil"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/fioncat/go-gendb/build"
	"github.com/fioncat/go-gendb/misc/set"
)

type Coder struct {
	Source string

	Pkg string

	Imports []Import
	Vars    []Var
	Consts  []Var
	Structs []Struct

	Contents []string

	importsSet *set.Set
}

type Var struct {
	Name  string
	Value string
}

type Import struct {
	Name string `json:"name"`
	Path string `json:"path"`
}

type Struct struct {
	Comment string  `json:"comment"`
	Name    string  `json:"name"`
	Fields  []Field `json:"fields"`

	fm map[string]struct{}
}

func (s *Struct) Merge(os *Struct) {
	if s.Name != os.Name {
		return
	}
	if s.fm == nil {
		s.fm = make(map[string]struct{})
		for _, f := range s.Fields {
			s.fm[f.Name] = struct{}{}
		}
	}

	for _, f := range os.Fields {
		_, ok := s.fm[f.Name]
		if ok {
			continue
		}
		s.Fields = append(s.Fields, f)
	}
}

type Field struct {
	Comment string     `json:"comment"`
	Name    string     `json:"name"`
	Type    string     `json:"type"`
	Tags    []FieldTag `json:"tags"`
}

func (f *Field) AddTag(name, val string) {
	tag := FieldTag{
		Name:  name,
		Value: val,
	}
	f.Tags = append(f.Tags, tag)
}

type FieldTag struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

var codePrefix = []string{
	"// Code generated by go-gendb. DO NOT EDIT.",
	"// go-gendb version: %s",
	"// source: %s",
}

func newVar(name string, vs ...interface{}) Var {
	val := comb(vs...)
	var v Var
	v.Name = name
	v.Value = val
	return v
}

func (c *Coder) AddStruct(s Struct) {
	c.Structs = append(c.Structs, s)
	for _, f := range s.Fields {
		if f.Type == "time.Time" {
			c.AddImport("time", "time")
		}
	}
}

func (c *Coder) AddImport(name, path string) {
	if c.importsSet == nil {
		c.importsSet = set.New()
	}
	if c.importsSet.Contains(name) {
		return
	}
	c.importsSet.Append(name)

	var imp Import
	imp.Name = name
	imp.Path = path

	c.Imports = append(c.Imports, imp)
}

func (c *Coder) AddVar(name string, vs ...interface{}) {
	c.Vars = append(c.Vars, newVar(name, vs...))
}

func (c *Coder) AddConst(name string, vs ...interface{}) {
	c.Consts = append(c.Consts, newVar(name, vs...))
}

func (c *Coder) P(n int, vs ...interface{}) {
	code := comb(vs...)
	prefix := strings.Repeat("\t", n)
	code = prefix + code
	c.Contents = append(c.Contents, code)
}

func (c *Coder) Empty() {
	c.Contents = append(c.Contents, "")
}

func (c *Coder) Write(path string) error {
	lines := make([]string, 0, 5+len(c.Contents))
	lines = append(lines, c.genHeader()...)
	lines = append(lines, c.genPkg())
	lines = append(lines, "")
	if len(c.Imports) > 0 {
		lines = append(lines, c.genImport()...)
		lines = append(lines, "")
	}
	if len(c.Vars) > 0 {
		lines = append(lines, c.genVars("var", c.Vars)...)
		lines = append(lines, "")
	}
	if len(c.Consts) > 0 {
		lines = append(lines, c.genVars("const", c.Consts)...)
		lines = append(lines, "")
	}
	if len(c.Structs) > 0 {
		lines = append(lines, c.genStructs()...)
		lines = append(lines, "")
	}
	lines = append(lines, c.Contents...)
	for i := range lines {
		lines[i] = strings.TrimRight(lines[i], " ")
	}

	data := []byte(strings.Join(lines, "\n"))

	return ioutil.WriteFile(path, data, 0644)
}

func (c *Coder) genHeader() []string {
	return []string{
		codePrefix[0],
		fmt.Sprintf(codePrefix[1], build.VERSION),
		fmt.Sprintf(codePrefix[2], c.Source),
	}
}

func (c *Coder) genPkg() string {
	return fmt.Sprintf("package %s", c.Pkg)
}

func (c *Coder) genImport() []string {
	sort.Slice(c.Imports, func(i, j int) bool {
		return c.Imports[i].Name < c.Imports[j].Name
	})
	lines := make([]string, 0, 2+len(c.Imports))
	lines = append(lines, "import (")
	for _, imp := range c.Imports {
		lines = append(lines, fmt.Sprintf(
			"\t%s %s", imp.Name, Quote(imp.Path)))
	}
	lines = append(lines, ")")
	return lines
}

func (c *Coder) genVars(def string, vs []Var) []string {
	lines := make([]string, 0, 2+len(c.Vars))
	lines = append(lines, fmt.Sprintf("%s (", def))
	align := 0
	for _, v := range vs {
		if len(v.Name) > align {
			align = len(v.Name)
		}
	}
	for _, v := range vs {
		lines = append(lines, fmt.Sprintf(
			"\t%s = %s", StrAlign(v.Name, align), v.Value))
	}
	lines = append(lines, ")")
	return lines
}

func (c *Coder) genStructs() []string {
	lines := make([]string, 0)
	for _, s := range c.Structs {
		comment := fmt.Sprintf("// %s %s",
			s.Name, s.Comment)
		def := fmt.Sprintf("type %s struct {", s.Name)
		lines = append(lines, comment)
		lines = append(lines, def)
		for _, f := range s.Fields {
			fcomment := fmt.Sprintf("\t// %s %s",
				f.Name, f.Comment)
			var fdef string
			if len(f.Tags) > 0 {
				tags := make([]string, len(f.Tags))
				for i, t := range f.Tags {
					tags[i] = fmt.Sprintf(`%s:"%s"`,

						t.Name, t.Value)
				}
				tagDef := strings.Join(tags, " ")
				fdef = fmt.Sprintf("\t%s %s `%s`",
					f.Name, f.Type, tagDef)
			} else {
				fdef = fmt.Sprintf("\t%s %s",
					f.Name, f.Type)
			}
			lines = append(lines, fcomment)
			lines = append(lines, fdef)
		}
		lines = append(lines, "}")
		lines = append(lines, "")
	}
	return lines
}

func comb(vs ...interface{}) string {
	strs := make([]string, len(vs))
	for i, v := range vs {
		strs[i] = fmt.Sprint(v)
	}
	return strings.Join(strs, "")
}

func Quote(ss ...string) string {
	s := strings.Join(ss, "")
	return fmt.Sprintf(`"%s"`, s)
}

func IsSimpleType(t string) bool {
	switch {
	case strings.HasPrefix(t, "int"):
		return true
	case strings.HasPrefix(t, "uint"):
		return true

	case t == "string":
		return true

	case t == "bool":
		return true

	case strings.HasPrefix(t, "float"):
		return true

	}

	return false
}

func GoName(name string) string {
	if name == "" {
		return ""
	}
	parts := strings.Split(name, "_")
	for i := range parts {
		parts[i] = Export(parts[i])
	}

	return strings.Join(parts, "")
}

func Export(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return string(unicode.ToLower(rune(s[0])))
	}
	return string(unicode.ToUpper(rune(s[0]))) + s[1:]
}

func Unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return string(unicode.ToLower(rune(s[0])))
	}
	return string(unicode.ToLower(rune(s[0]))) + s[1:]
}

func StrAlign(s string, fix int) string {
	format := "%-" + strconv.Itoa(fix) + "s"
	return fmt.Sprintf(format, s)
}
