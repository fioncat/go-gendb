package generate

import (
	"fmt"
	"io/ioutil"
	"path/filepath"
	"strings"
	"time"

	"github.com/fioncat/go-gendb/coder"
	"github.com/fioncat/go-gendb/compile/golang"
	"github.com/fioncat/go-gendb/database/rdb"
	"github.com/fioncat/go-gendb/link"
	"github.com/fioncat/go-gendb/misc/errors"
	"github.com/fioncat/go-gendb/misc/log"
	"github.com/fioncat/go-gendb/version"
)

type Arg struct {
	Output  string `flag:"o"`
	Package string `flag:"pkg"`

	Log     bool   `flag:"log"`
	LogPath string `flag:"log-path"`
	Cache   bool   `flag:"cache"`

	CacheTTL string `flag:"cache-ttl"`

	Path string `arg:"path"`
}

func Do(arg *Arg) error {
	if arg.Log {
		log.Init(true, arg.LogPath)
	}
	if arg.Cache {
		rdb.EnableTableCache = true
	}
	if arg.CacheTTL != "" {
		cacheDuration, err := time.ParseDuration(arg.CacheTTL)
		if err != nil {
			return fmt.Errorf(`cache-ttl "%s" is bad format`,
				arg.CacheTTL)
		}
		rdb.TableCacheTTL = cacheDuration
	}
	data, err := ioutil.ReadFile(arg.Path)
	if err != nil {
		return err
	}
	lines := strings.Split(string(data), "\n")

	file, err := golang.ReadLines(arg.Path, lines)
	if err != nil {
		return err
	}

	res, err := link.Do(file)
	if err != nil {
		err = errors.OnCompile(arg.Path, lines, err)
		return err
	}

	if arg.Package != "" {
		res.Package = arg.Package
	}

	for _, t := range res.Targets {
		start := time.Now()
		c, err := gen(res, t)
		if err != nil {
			return err
		}
		var path string
		if arg.Output != "" {
			path = arg.Output
		} else {
			path = filepath.Dir(arg.Path)
		}

		filename := fmt.Sprintf("zz_generated_%s.go", t.Name())
		path = filepath.Join(path, filename)

		err = c.WriteFile(path)
		if err != nil {
			return err
		}
		log.Infof("[gen] [%v] %s, name=%s",
			time.Since(start), t.Path(), t.Name())
	}
	return nil
}

func gen(res *link.Result, t coder.Target) (*coder.Coder, error) {
	c := new(coder.Coder)
	c.P(0, "// Code generated by go-gendb, DO NOT EDIT.")
	c.P(0, "// go-gendb version: ", version.Short)
	c.P(0, "// source: ", t.Path())
	c.P(0, "package ", res.Package)
	c.Empty()

	importCoder := new(coder.Import)
	t.Imports(importCoder)
	c.AddSub(importCoder)

	constCoder := new(coder.Var)
	constCoder.Const = true
	t.Consts(constCoder, importCoder)
	c.AddSub(constCoder)

	varCoder := new(coder.Var)
	t.Vars(varCoder, importCoder)
	c.AddSub(varCoder)

	sg := new(coder.StructGroup)
	t.Structs(sg)
	for _, s := range sg.Gets() {
		c.AddSub(s)
	}

	fg := new(coder.FunctionGroup)
	t.Funcs(fg)
	for _, f := range fg.Gets() {
		c.AddSub(f)
	}

	for idx := 0; idx < t.StructNum(); idx++ {
		structCoder := new(coder.Struct)
		t.Struct(idx, structCoder, importCoder)
		c.AddSub(structCoder)
	}

	for idx := 0; idx < t.FuncNum(); idx++ {
		funcCoder := new(coder.Function)
		t.Func(idx, funcCoder, importCoder)
		c.AddSub(funcCoder)
	}
	err := importCoder.Check()
	if err != nil {
		return nil, err
	}

	c.Body()

	return c, nil
}
