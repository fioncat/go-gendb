// Code generated by go-gendb. DO NOT EDIT.
// go-gendb version: 0.1.4
// source: samples/crud/user.go
package user

import (
	fmt "fmt"
	query "github.com/fioncat/go-gendb/api/sql/query"
	run "github.com/fioncat/go-gendb/api/sql/run"
	sql "database/sql"
	strings "strings"
	update "github.com/fioncat/go-gendb/api/sql/update"
)

// User
type User struct {
	// Age 用户年龄
	Age int32 `field:"age"`
	// CreateTime 创建时间
	CreateTime string `field:"create_time"`
	// Email 用户邮箱
	Email string `field:"email"`
	// Id 用户id
	Id int64 `field:"id" id:"true"`
	// IsAdmin 是否是管理员 0-不是  1-是
	IsAdmin int32 `field:"is_admin"`
	// IsDelete
	IsDelete int32 `field:"is_delete"`
	// Name 用户名
	Name string `field:"name"`
	// Password 用户密码
	Password string `field:"password"`
	// Phone 用户电话
	Phone string `field:"phone"`
}


// all fields for `user`
const (
	// UserFieldCreateTime is the name of field `user`.create_time
	UserFieldCreateTime = "`create_time`"
	// UserFieldIsAdmin is the name of field `user`.is_admin
	UserFieldIsAdmin = "`is_admin`"
	// UserFieldName is the name of field `user`.name
	UserFieldName = "`name`"
	// UserFieldPassword is the name of field `user`.password
	UserFieldPassword = "`password`"
	// UserFieldPhone is the name of field `user`.phone
	UserFieldPhone = "`phone`"
	// UserFieldAge is the name of field `user`.age
	UserFieldAge = "`age`"
	// UserFieldId is the name of field `user`.id
	UserFieldId = "`id`"
	// UserFieldIsDelete is the name of field `user`.is_delete
	UserFieldIsDelete = "`is_delete`"
	// UserFieldEmail is the name of field `user`.email
	UserFieldEmail = "`email`"

	UserTable = "`user`"
)

// auto-generated sql statements
const (
	// _User_Insert is the sql for <Insert> operation.
	_User_Insert = "INSERT INTO `user`(`create_time`,`is_admin`,`name`,`password`,`phone`,`age`,`is_delete`,`email`) VALUES (?,?,?,?,?,?,?,?)"
	// _User_Batch is the sql for <Insert-Batch> operation.
	_User_Batch_0 = "INSERT INTO `user`(`create_time`,`is_admin`,`name`,`password`,`phone`,`age`,`is_delete`,`email`) VALUES %s"
	_User_Batch_1 = "(?,?,?,?,?,?,?,?),"
	// _User_Delete is the sql for <Delete> operation.
	_User_Delete = "DELETE FROM `user` WHERE `id`=?"
	// _User_Update is the sql for <Update> operation.
	_User_Update = "UPDATE `user` SET `create_time`=?,`is_admin`=?,`name`=?,`password`=?,`phone`=?,`age`=?,`is_delete`=?,`email`=? WHERE `id`=?"
	// _User_Upsert is the sql for <Upsert> operation.
	_User_Upsert = "INSERT INTO `user`(`create_time`,`is_admin`,`name`,`password`,`phone`,`age`,`id`,`is_delete`,`email`) VALUES (?,?,?,?,?,?,?,?,?) ON DUPLICATE KEY UPDATE `create_time`=?,`is_admin`=?,`name`=?,`password`=?,`phone`=?,`age`=?,`is_delete`=?,`email`=?"
	// _User_FindById is the sql for <FindById> operation.
	_User_FindById = "SELECT `create_time`,`is_admin`,`name`,`password`,`phone`,`age`,`id`,`is_delete`,`email` FROM `user` WHERE `id`=?"
	// _User_FindAll is the sql for <FindAll> operation.
	_User_FindAll = "SELECT `create_time`,`is_admin`,`name`,`password`,`phone`,`age`,`id`,`is_delete`,`email` FROM `user`"
)

// UserFields stores all field names for table `user`
var UserFields = []string{
	UserFieldCreateTime,
	UserFieldIsAdmin,
	UserFieldName,
	UserFieldPassword,
	UserFieldPhone,
	UserFieldAge,
	UserFieldId,
	UserFieldIsDelete,
	UserFieldEmail,
}

// UserORM is the global variable to process orm-operation for `user`
var UserORM = &UserORMImpl{}

type UserORMImpl struct {
}

func (*UserORMImpl) BatchInsert(db run.IDB, os []*User) (sql.Result, error) {
	vs := make([]interface{}, 0, 8*len(os))
	for _, o := range os {
		vs = append(vs, o.CreateTime, o.IsAdmin, o.Name, o.Password, o.Phone, o.Age, o.IsDelete, o.Email)
	}
	valuesStr := strings.Repeat(_User_Batch_1, len(os))
	valuesStr = valuesStr[:len(valuesStr)-1]
	_sql := fmt.Sprintf(_User_Batch_0, valuesStr)
	return run.Exec(db, _sql, nil, vs)
}

func (*UserORMImpl) Update(db run.IDB, u *update.Update) (sql.Result, error) {
	_sql, vs := u.Build(UserTable)
	return run.Exec(db, _sql, nil, vs)
}

func (*UserORMImpl) FindById(db run.IDB, id int64) (o *User, err error) {
	err = run.QueryOne(db, _User_FindById, nil, []interface{}{id}, func(rows *sql.Rows) error {
		o = new(User)
		return rows.Scan(&o.CreateTime, &o.IsAdmin, &o.Name, &o.Password, &o.Phone, &o.Age, &o.Id, &o.IsDelete, &o.Email)
	})
	return
}

func (*UserORMImpl) Search(db run.IDB, q *query.Query) (os []*User, err error) {
	_sql, vs := q.Build(UserTable, UserFields)
	err = run.QueryMany(db, _sql, nil, vs, func(rows *sql.Rows) error {
		o := new(User)
		err := rows.Scan(&o.CreateTime, &o.IsAdmin, &o.Name, &o.Password, &o.Phone, &o.Age, &o.Id, &o.IsDelete, &o.Email)
		if err != nil {
			return err
		}
		os = append(os, o)
		return nil
	})
	return
}

func (*UserORMImpl) Walk(db run.IDB, batchSize int64, walkFunc func(os []*User) error) error {
	_sql := _User_FindAll + " LIMIT ?,?"
	var offset int64 = 0
	for {
		var os []*User
		err := run.QueryMany(db, _sql, nil, []interface{}{offset, batchSize}, func(rows *sql.Rows) error {
			o := new(User)
			err := rows.Scan(&o.CreateTime, &o.IsAdmin, &o.Name, &o.Password, &o.Phone, &o.Age, &o.Id, &o.IsDelete, &o.Email)
			if err != nil {
				return err
			}
			os = append(os, o)
			return nil
		})
		if err != nil {
			return err
		}
		if len(os) == 0 {
			return nil
		}
		offset += batchSize
		err = walkFunc(os)
		if err != nil {
			return err
		}
	}
}

func (o *User) Save(db run.IDB) (sql.Result, error) {
	return run.Exec(db, _User_Upsert, nil, []interface{}{o.CreateTime, o.IsAdmin, o.Name, o.Password, o.Phone, o.Age, o.Id, o.IsDelete, o.Email, o.CreateTime, o.IsAdmin, o.Name, o.Password, o.Phone, o.Age, o.IsDelete, o.Email})
}

func (o *User) Add(db run.IDB) (sql.Result, error) {
	return run.Exec(db, _User_Insert, nil, []interface{}{o.CreateTime, o.IsAdmin, o.Name, o.Password, o.Phone, o.Age, o.IsDelete, o.Email})
}

func (o *User) UpdateById(db run.IDB) (sql.Result, error) {
	return run.Exec(db, _User_Update, nil, []interface{}{o.CreateTime, o.IsAdmin, o.Name, o.Password, o.Phone, o.Age, o.IsDelete, o.Email, o.Id})
}

func (o *User) Remove(db run.IDB) (sql.Result, error) {
	return run.Exec(db, _User_Delete, nil, []interface{}{o.Id})
}
