// Code generated by go-gendb. DO NOT EDIT.
// go-gendb version: 0.1.1
// source: samples/dynamic/user.go
package user

import (
	runner "github.com/fioncat/go-gendb/api/sqlrunner"
	sql "database/sql"
	strings "strings"
)

const (
	sql_UserDb_BatchInsert_0 = "INSERT INTO user(id,name,age,phone,is_admin) VALUES"
	sql_UserDb_BatchInsert_1 = "(?, ?, ?, ?, ?),"
	sql_UserDb_FindById      = "SELECT id, name FROM user WHERE id=?"
	sql_UserDb_FindByIds_0   = "SELECT id, name FROM user WHERE id IN ("
	sql_UserDb_FindByIds_1   = "?,"
	sql_UserDb_FindByIds_2   = ")"
	sql_UserDb_Update_0      = "UPDATE user SET 1=1"
	sql_UserDb_Update_1      = "AND name=?"
	sql_UserDb_Update_2      = "AND age=?"
	sql_UserDb_Update_3      = "AND phone=?"
	sql_UserDb_Update_4      = "WHERE id=?"
)

// _UserDbImpl implement of UserDb
type _UserDbImpl struct {
}

var UserDbOper UserDb = &_UserDbImpl{}

// BatchInsert implement of UserDb.BatchInsert
func (*_UserDbImpl) BatchInsert(db *sql.DB, users []*User) (int64, error) {
	// >>> concat start.
	pvs := make([]interface{}, 0, 5*len(users))
	slice := make([]string, 0, 1+len(users))
	// concat: part 0
	slice = append(slice, sql_UserDb_BatchInsert_0)
	// concat: part 1
	lastidx := len(sql_UserDb_BatchInsert_1) - 1
	for i, u := range users {
		pvs = append(pvs, u.Id, u.Name, u.Age, u.Phone, u.IsAdmin)
		if i == len(users) - 1 {
			slice = append(slice, sql_UserDb_BatchInsert_1[:lastidx])
		} else {
			slice = append(slice, sql_UserDb_BatchInsert_1)
		}
	}
	// do concat
	_sql := strings.Join(slice, " ")
	// >>> concat done.
	return runner.ExecAffect(db, _sql, pvs, nil)
}

// FindById implement of UserDb.FindById
func (*_UserDbImpl) FindById(db *sql.DB, id int64) (*User, error) {
	var o *User
	err := runner.QueryOne(db, sql_UserDb_FindById, []interface{}{id}, nil, func(rows *sql.Rows) error {
		o = new(User)
		return rows.Scan(&o.Id, &o.Name)
	})
	return o, err
}

// FindByIds implement of UserDb.FindByIds
func (*_UserDbImpl) FindByIds(db *sql.DB, ids []string) ([]*User, error) {
	// >>> concat start.
	pvs := make([]interface{}, 0, len(ids))
	slice := make([]string, 0, 2+len(ids))
	// concat: part 0
	slice = append(slice, sql_UserDb_FindByIds_0)
	// concat: part 1
	lastidx := len(sql_UserDb_FindByIds_1) - 1
	for i, id := range ids {
		pvs = append(pvs, id)
		if i == len(ids) - 1 {
			slice = append(slice, sql_UserDb_FindByIds_1[:lastidx])
		} else {
			slice = append(slice, sql_UserDb_FindByIds_1)
		}
	}
	// concat: part 2
	slice = append(slice, sql_UserDb_FindByIds_2)
	// do concat
	_sql := strings.Join(slice, " ")
	// >>> concat done.
	var os []*User
	err := runner.QueryMany(db, _sql, pvs, nil, func(rows *sql.Rows) error {
		o := new(User)
		err := rows.Scan(&o.Id, &o.Name)
		if err != nil {
			return err
		}
		os = append(os, o)
		return nil
	})
	return os, err
}

// Update implement of UserDb.Update
func (*_UserDbImpl) Update(db *sql.DB, u *User) (int64, error) {
	// >>> concat start.
	pvs := make([]interface{}, 0, 4)
	slice := make([]string, 0, 5)
	// concat: part 0
	slice = append(slice, sql_UserDb_Update_0)
	// concat: part 1
	if u.Name != "" {
		slice = append(slice, sql_UserDb_Update_1)
		pvs = append(pvs, u.Name)
	}
	// concat: part 2
	if u.Age > 0 {
		slice = append(slice, sql_UserDb_Update_2)
		pvs = append(pvs, u.Age)
	}
	// concat: part 3
	if u.Phone != "" {
		slice = append(slice, sql_UserDb_Update_3)
		pvs = append(pvs, u.Phone)
	}
	// concat: part 4
	slice = append(slice, sql_UserDb_Update_4)
	pvs = append(pvs, u.Id)
	// do concat
	_sql := strings.Join(slice, " ")
	// >>> concat done.
	return runner.ExecAffect(db, _sql, pvs, nil)
}
