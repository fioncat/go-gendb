// Code generated by go-gendb, DO NOT EDIT.
// go-gendb version: 0.3
// source: samples/orm-mgo/item.go
package item

import (
	bson "gopkg.in/mgo.v2/bson"
	mgo "gopkg.in/mgo.v2"
	mgoapi "github.com/fioncat/go-gendb/api/mgo"
)

const (
	BaseCollection = "base"
	BaseDatabase   = "item"
)

const (
	BaseFieldID         = "_id"
	BaseFieldGpid       = "gpid"
	BaseFieldParentGpid = "parent_gpid"
	BaseFieldInSale     = "in_sale"
	BaseFieldAttrs      = "attrs"
	BaseFieldUpdateDate = "update_date"
)

const (
	BaseSortIDDesc         = "-_id"
	BaseSortUpdateDateDesc = "-update_date"
)

var BaseOper = &_BaseOper{}

type Base struct {
	ID         bson.ObjectId `bson:"_id,omitempty" json:"id"`
	Gpid       int64         `bson:"gpid" json:"gpid"`
	ParentGpid int64         `bson:"parent_gpid" json:"parent_gpid"`
	InSale     bool          `bson:"in_sale" json:"in_sale"`
	Attrs      []*SkuAttr    `bson:"attrs" json:"attrs"`
	UpdateDate int64         `bson:"update_date" json:"update_date"`
}

type _BaseOper struct {}

type BaseQuery struct {
	 *mgoapi.Query
}

func (o *Base) Id() string {
	return o.ID.Hex()
}

func EnsureBaseIndexes(sess *mgo.Session) error {
	_sess, col := BaseOper.GetCol(sess)
	defer _sess.Close()
	if err := col.EnsureIndex(mgo.Index{
		Key:        []string{BaseFieldParentGpid},
		Background: true,
		Sparse:     true,
	}); err != nil {
		return err
	}

	if err := col.EnsureIndex(mgo.Index{
		Key:        []string{BaseFieldUpdateDate},
		Background: true,
		Sparse:     true,
	}); err != nil {
		return err
	}

	if err := col.EnsureIndex(mgo.Index{
		Key:        []string{BaseFieldGpid},
		Background: true,
		Unique:     true,
		Sparse:     true,
	}); err != nil {
		return err
	}

	return nil
}

func (o *Base) Save(sess *mgo.Session) (*mgo.ChangeInfo, error) {
	sess, col := BaseOper.GetCol(sess)
	defer sess.Close()
	return col.UpsertId(o.Id, o)
}

func (q *BaseQuery) All() (os []*Base, err error) {
	err = q.MarshalAll(&os)
	return
}

func (q *BaseQuery) One() (o *Base, err error) {
	err = q.MarshalOne(&o)
	return
}

func (q *BaseQuery) Walk(walkFunc func(o *Base) error) error {
	iter := q.Iter()
	var o *Base
	for iter.Next(&o) {
		err := walkFunc(o)
		if err != nil {
			return err
		}
	}
	return iter.Err()
}

func (oper *_BaseOper) GetCol(sess *mgo.Session) (*mgo.Session, *mgo.Collection) {
	_sess := sess.Clone()
	return _sess, _sess.DB(BaseDatabase).C(BaseCollection)
}

func (oper *_BaseOper) Find(sess *mgo.Session, query interface{}) *BaseQuery {
	_sess, col := oper.GetCol(sess)
	mq := col.Find(query)
	return &BaseQuery{Query: mgoapi.NewQuery(mq, _sess)}
}

func (oper *_BaseOper) FindById(sess *mgo.Session, id string) (*Base, error) {
	if !bson.IsObjectIdHex(id) {
		return nil, mgo.ErrNotFound
	}
	_sess, col := oper.GetCol(sess)
	defer _sess.Close()
	var o *Base
	err := col.FindId(bson.ObjectIdHex(id)).One(&o)
	return o, err
}

func (oper *_BaseOper) CountE(sess *mgo.Session, query interface{}) (int, error) {
	_sess, col := oper.GetCol(sess)
	defer _sess.Close()
	return col.Find(query).Count()
}

func (oper *_BaseOper) Count(sess *mgo.Session, query interface{}) int {
	cnt, _ := oper.CountE(sess, query)
	return cnt
}

func (oper *_BaseOper) Remove(sess *mgo.Session, query interface{}) (*mgo.ChangeInfo, error) {
	_sess, col := oper.GetCol(sess)
	defer _sess.Close()
	return col.RemoveAll(query)
}

func (oper *_BaseOper) RemoveById(sess *mgo.Session, id string) error {
	_sess, col := oper.GetCol(sess)
	defer _sess.Close()
	if !bson.IsObjectIdHex(id) {
		return mgo.ErrNotFound
	}
	return col.RemoveId(bson.ObjectIdHex(id))
}

func (oper *_BaseOper) FindManyByParentGpid(sess *mgo.Session, parentGpid int64) ([]*Base, error) {
	q := oper.Find(sess, bson.M{BaseFieldParentGpid: parentGpid})
	return q.All()
}

func (oper *_BaseOper) FindOneByGpid(sess *mgo.Session, gpid int64) (*Base, error) {
	q := oper.Find(sess, bson.M{BaseFieldGpid: gpid})
	return q.One()
}