// Code generated by go-gendb, DO NOT EDIT.
// go-gendb version: 0.3
// source: samples/orm-mgo/item.go
package item

import (
	bson "gopkg.in/mgo.v2/bson"
	mgo "gopkg.in/mgo.v2"
)

const (
	BaseCollection = "base"
	BaseDatabase   = "item"
)

const (
	BaseFieldID         = "_id"
	BaseFieldGpid       = "gpid"
	BaseFieldParentGpid = "parent_gpid"
	BaseFieldInSale     = "in_sale"
	BaseFieldAttrs      = "attrs"
)

const BaseSortIDDesc = "-_id"

var BaseOper = &_BaseOper{}

type Base struct {
	ID         bson.ObjectId `bson:"_id,omitempty" json:"id"`
	Gpid       int64         `bson:"gpid" json:"gpid"`
	ParentGpid int64         `bson:"parent_gpid" json:"parent_gpid"`
	InSale     bool          `bson:"in_sale" json:"in_sale"`
	Attrs      []*SkuAttr    `bson:"attrs" json:"attrs"`
}

type _BaseOper struct {}

type BaseQuery struct {
	mq   *mgo.Query
	sess *mgo.Session
}

func (o *Base) Id() string {
	return o.ID.Hex()
}

func (o *Base) Save(sess *mgo.Session) (*mgo.ChangeInfo, error) {
	sess, col := BaseOper.GetCol(sess)
	defer sess.Close()
	return col.UpsertId(o.Id, o)
}

func (q *BaseQuery) Select(fields ...string) *BaseQuery {
	m := make(bson.M, len(fields))
	for _, field := range fields {
		m[field] = 1
	}
	q.mq.Select(m)
	return q
}

func (q *BaseQuery) Limit(offset, limit int) *BaseQuery {
	if limit > 0 {
		q.mq.Limit(limit)
	}
	if offset > 0 {
		q.mq.Skip(offset)
	}
	return q
}

func (q *BaseQuery) Sort(fields ...string) *BaseQuery {
	q.mq.Sort(fields...)
	return q
}

func (q *BaseQuery) All() (os []*Base, err error) {
	defer q.sess.Close()
	err = q.mq.All(&os)
	return
}

func (q *BaseQuery) One() (o *Base, err error) {
	defer q.sess.Close()
	err = q.mq.One(&o)
	return
}

func (oper *_BaseOper) GetCol(sess *mgo.Session) (*mgo.Session, *mgo.Collection) {
	_sess := sess.Clone()
	return _sess, _sess.DB(BaseDatabase).C(BaseCollection)
}

func (oper *_BaseOper) Find(sess *mgo.Session, query interface{}) *BaseQuery {
	_sess, col := oper.GetCol(sess)
	mq := col.Find(query)
	return &BaseQuery{mq: mq, sess: _sess}
}

func (oper *_BaseOper) FindById(sess *mgo.Session, id string) (*Base, error) {
	if !bson.IsObjectIdHex(id) {
		return nil, mgo.ErrNotFound
	}
	_sess, col := oper.GetCol(sess)
	defer _sess.Close()
	var o *Base
	err := col.FindId(bson.ObjectIdHex(id)).One(&o)
	return o, err
}